# 🛡️ SafeMask 架构详解 (Part 2: 核心脱敏引擎与冲突算法)

核心引擎是 SafeMask 的技术壁垒所在。它不仅要求匹配**准**，更要求在处理海量数据时达到**极致的速度**。本章将深入解析 `src-tauri/src/core/engine.rs` 中的实现细节。

---

## 1. 混合引擎设计 (Hybrid Matching Engine)

SafeMask 并没有简单地遍历正则表达式，而是采用了 **“分类分级”** 的混合匹配策略，将规则分为两个阶段处理：

### A. 第一阶段：Aho-Corasick (AC) 自动机
*   **适用对象**：固定字符串规则（如特定的项目名、人名、关键字）。
*   **原理**：引擎在预编译阶段通过 `is_literal` 函数检测模式是否包含正则元字符。如果是纯文本，则将其注入 AC 自动机。
*   **优势**：无论词库中有 10 条还是 10,000 条规则，AC 自动机都能在 $O(n)$ 时间复杂度内（仅需扫描一次原文）完成所有匹配，完美规避正则引擎的性能波动。

### B. 第二阶段：字节级正则 (Byte-Level Regex)
*   **适用对象**：动态模式规则（如手机号、IPv4、Email）。
*   **原理**：基于 `regex::bytes::Regex` 实现。
*   **优化**：SafeMask 直接在原生字节流（`[u8]`）上进行操作，**完全跳过了 Rust 默认的 UTF-8 字符校验**。这对于处理包含非法字符或非 UTF-8 编码的原始日志文件至关重要，性能提升约 20%-30%。

---

## 2. 冲突解决算法 (Conflict Resolution)

在实际脱敏中，多个规则经常会匹配到同一段文本。例如：
原文：`Visit http://192.168.1.1:8080`
*   规则 A (IPv4) 匹配到 `192.168.1.1`
*   规则 B (URL) 匹配到 `http://192.168.1.1:8080`

如果简单地进行替换，会导致文本结构破坏或二次污染。SafeMask 采用了 **“贪婪合并排序算法”**：

### 算法步骤 (`apply_replacements`)：
1.  **收集 (Collect)**：将 AC 引擎和 Regex 引擎发现的所有匹配片段（MatchSpan）放入一个集合。
2.  **多维排序 (Multi-level Sort)**：
    *   **第一维：起始位置 (Start)** 升序。确保从左往右处理。
    *   **第二维：优先级 (Priority)** 降序。数值越大，越先被保留。
    *   **第三维：匹配长度 (Length)** 降序。在优先级相同时，越长的匹配（包含信息越多）越优先。
3.  **单次扫描合并 (Single-pass Merge)**：
    *   遍历排序后的片段。
    *   如果当前片段与上一个已确定的片段有重叠（`m.start < last_pos`），则直接**丢弃**当前片段。
    *   由于经过了高优排序，留下的永远是权重最高、范围最广的脱敏结果。

---

## 3. 内存优化策略

### A. 零拷贝抽象 (Zero-Copy COW)
引擎接口使用 `Cow<'a, [u8]>` (Copy-On-Write)：
*   如果一行文本中**没有**发现敏感信息，引擎直接返回原文的引用（Borrowed），**不产生任何内存分配**。
*   只有发现敏感信息时，才会分配新的空间（Owned）来存储脱敏后的数据。

### B. 预分配缓冲区
在冲突合并逻辑中，使用 `Vec::with_capacity(input.len())`。通过预估输出大小，减少了文本拼接过程中因数组扩容导致的 CPU 昂贵开销。

---

## 4. 引擎核心结构示意 (Core Struct)

```rust
pub struct MaskEngine {
    // 处理固定词，O(n) 复杂度
    ac_engine: Option<AhoCorasick>,
    ac_masks: Vec<Vec<u8>>,
    
    // 处理正则表达式，按优先级排序
    regex_rules: Vec<CompiledRegex>,
}
```