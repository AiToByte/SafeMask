这份架构图展示了 **SafeMask v0.5.0** 的核心设计，即 **“三阶段保序流水线 (Three-Stage Ordered Pipeline)”**。这种设计是高性能系统编程的典型范式，旨在消除 I/O 阻塞并最大化 CPU 利用率。

---

### 🎨 SafeMask v0.5.0 逻辑架构图

```text
                                  +---------------------------+
                                  |   YAML Configuration      |
                                  | (AI, DB, Network Rules)   |
                                  +------------+--------------+
                                               |
                                               v
+---------------------------------------------------------------------------------------+
|                               STAGE 1: PRODUCER (I/O)                                 |
|  +---------------------------------------------------------------------------------+  |
|  |  [ Disk File ] -> Memory Mapping (mmap2) -> Pointer-based Macro Chunks (4MB)    |  |
|  +---------------------------------------+-----------------------------------------+  |
+------------------------------------------|--------------------------------------------+
                                           |
                                (Crossbeam Channel - Tx1)
                                           |
+------------------------------------------v--------------------------------------------+
|                               STAGE 2: WORKER CLUSTER (CPU)                           |
|      (Rayon Thread Pool - Parallel Data Transformation / Zero-Allocation)             |
|                                                                                       |
|  +-------------------+        +-------------------+        +-------------------+      |
|  |  Worker Thread 1  |        |  Worker Thread 2  |        |  Worker Thread N  |      |
|  | [Byte-Level RE/AC]|        | [Byte-Level RE/AC]|        | [Byte-Level RE/AC]|      |
|  +---------+---------+        +---------+---------+        +---------+---------+      |
|            |                            |                            |                |
|      (Local Buffer)               (Local Buffer)               (Local Buffer)         |
+------------------------------------------|--------------------------------------------+
                                           |
                                (Crossbeam Channel - Tx2)
                                           |
+------------------------------------------v--------------------------------------------+
|                               STAGE 3: CONSUMER (ORDERED WRITER)                      |
|  +---------------------------------------------------------------------------------+  |
|  |  Priority Queue (BTreeMap) -> Sequence Matching -> BufWriter (8MB Aggregation)  |  |
|  +---------------------------------------+-----------------------------------------+  |
+------------------------------------------|--------------------------------------------+
                                           |
                                           v
                                  [ Desensitized Output ]
                                  (File / Stdout / Stream)
```

---

### 📝 详细架构说明

#### 1. Stage 1: 生产者 (高效数据加载)
*   **Memory Mapping (Mmap)**：弃用传统的 `read()` 系统调用。通过 `mmap2` 将文件直接映射到进程的虚拟地址空间。这样做减少了数据从内核缓冲区到用户缓冲区的昂贵拷贝。
*   **Macro-Chunking**：将文件指针划分为 4MB 的逻辑大块（Macro-Chunks）。每个块被赋予一个单调递增的 `ChunkID`。
*   **任务分发**：将 `(ChunkID, &[u8])` 发送到高性能的 `crossbeam-channel`。

#### 2. Stage 2: 并行计算集群 (算力压榨)
*   **Rayon 并行流水线**：利用 Rayon 的“工作窃取（Work-Stealing）”调度算法，确保所有 CPU 核心负载均衡。
*   **字节流引擎 (Byte-level Engine)**：
    *   **Regex::bytes**：直接在原始字节切片上运行正则，完全绕过 Rust `&str` 强制的 UTF-8 编码校验。
    *   **Aho-Corasick**：用于极速扫描固定敏感词字典。
*   **Scratch Buffer 重用**：每个工作线程持有一个预分配的缓存区，通过 `map_init` 模式实现内存复用，将内存申请开销降低到近乎零。

#### 3. Stage 3: 有序消费者 (保序与高效写入)
*   **BTreeMap 优先级队列**：并行计算会导致块的完成顺序不确定（例如第 5 块可能比第 1 块先算完）。Stage 3 使用 `BTreeMap<ChunkID, Vec<u8>>` 作为中转站。
*   **Sequence Matching**：写入线程只在收到“下一个期望的 ID”时才执行写入。如果收到的是后续块，则暂存在内存中。这保证了脱敏后的日志顺序与原始文件 100% 一致。
*   **8MB 聚合写入**：通过大容量 `BufWriter` 减少系统调用频率，利用操作系统的顺序 I/O 优势。

---

### 🔥 核心技术亮点 (面试/简历加分项)

1.  **I/O 与计算重叠 (Latency Hiding)**：
    这是 v0.5.0 最本质的飞跃。在以往版本中，CPU 计算时磁盘是闲置的。现在的架构下，**磁盘读取（Stage 1）、CPU 脱敏（Stage 2）和磁盘写入（Stage 3）是全并行的同步流水线**。总耗时仅取决于这三者中最慢的一个。

2.  **零分配 (Zero-Allocation) 倾向**：
    整个处理链路尽可能维持在字节切片（Slice）层面，仅在必须时（即确实发现敏感词需要替换时）才产生新的内存分配。

3.  **无锁通信**：
    使用了 `crossbeam-channel` 这一基于多生产者多消费者（MPMC）的无锁/低锁队列，避免了传统 Mutex 在高并发下的竞争瓶颈。

4.  **保序性保障**：
    解决了并行计算中常见的“乱序（Out-of-order）”痛点，使得 SafeMask 可以直接用于对时间序有严格要求的生产环境数据库审计和系统日志处理。

---

### 🚀 性能总结
这种架构让 **SafeMask** 成功转型为一个**流式处理引擎**。当你在处理 100GB 的文件时，程序不会因为读取而停下，也不会因为内存爆仓而崩溃，它会像流过管道的水一样，以稳定的 500MB/s - 800MB/s 速度完成脱敏。