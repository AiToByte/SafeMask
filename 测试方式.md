为了真正压测 **`safemask`** 的 **Mmap（内存映射）** 和 **Rayon（多核并行）** 特性，我们需要把数据量提升到 **GB 级别（例如 5GB - 10GB）**。

在 Windows PowerShell 中，高效生成大文件有两种推荐方案：

---

### 方案一：倍增法（最快，利用现有文件）
如果你已经生成了那个 200MB 的 `test_perf.log`，我们可以利用文件流直接把它快速复制并合并，实现容量翻倍。

**在 PowerShell 中运行以下代码：**

```powershell
# 将 200MB 的文件自我复制合并，运行 5 次就是 32 倍 (约 6.4GB)
$source = "test_perf.log"
$target = "test_big_5gb.log"

Write-Host "🚀 正在通过倍增法生成大文件..." -ForegroundColor Cyan

# 先拷贝一份作为基础
Copy-Item $source $target

# 循环 5 次，每次文件大小翻倍：200MB -> 400 -> 800 -> 1.6G -> 3.2G -> 6.4G
for ($i = 1; $i -le 5; $i++) {
    Write-Host "正在进行第 $i 次翻倍..."
    # 使用 CMD 的二进制拷贝模式，这是 Windows 下合并文件最快的方式
    cmd /c "copy /b $target + $target $target_tmp"
    Move-Item $target_tmp $target -Force
}

Write-Host "✅ 成功生成超大测试文件: $target" -ForegroundColor Green
```

---

### 方案二：高性能 .NET 流生成器（生成 1000 万行 ≈ 2GB）
如果你想生成更具随机性的数据，我们可以把循环次数加大。为了避免 PowerShell 自身的性能瓶颈，我们增大缓冲区。

```powershell
$path = "test_perf_GB.log"
$lines = 10000000  # 1000 万行

# 1. 初始化随机数发生器实例 (修复报错的关键)
$rand = [System.Random]::new()

# 2. 定义缺失的变量库
$domains = @("internal.cloud", "prod.corp", "dev.local", "secure.node", "api.service.io")
$phonePrefixes = @("138", "139", "150", "159", "170", "188", "133", "189", "131")

Write-Host "🚀 正在生成 1000 万行压力测试数据..." -ForegroundColor Cyan

# 3. 使用 64KB 缓冲区以提升写入速度
$sw = [System.IO.StreamWriter]::new((Join-Path (Get-Location) $path), $false, [System.Text.Encoding]::UTF8, 65536)

for ($i = 1; $i -le $lines; $i++) {
    # 4. 正确调用随机数实例方法 .Next()
    $ip = "$($rand.Next(1,255)).$($rand.Next(0,255)).$($rand.Next(0,255)).$($rand.Next(0,255))"
    
    # 随机选择前缀并生成手机号
    $prefix = $phonePrefixes[$rand.Next(0, $phonePrefixes.Length)]
    $phone = "$prefix$($rand.Next(10000000, 99999999))"
    
    # 生成 UUID 相关的随机数据
    $guid = [guid]::NewGuid().ToString()
    $email = "user_$($guid.Substring(0,8))@$($domains[$rand.Next(0, $domains.Length)])"
    $dns = "node-$($rand.Next(100,999)).$($domains[$rand.Next(0, $domains.Length)])"
    
    $db_uri = "postgres://admin:pwd$($rand.Next(1000,9999))@$dns:5432/db_main"
    
    # 构造一行混合日志
    $line = "INFO [2026-01-09] REQ_ID:$guid | Client: $ip | Phone: $phone | Email: $email | DNS: $dns | DB: $db_uri | Key: sk-$($guid)$($guid)"
    
    $sw.WriteLine($line)
    
    # 每 100 万行报告一次进度
    if ($i % 1000000 -eq 0) { 
        $percent = ($i / $lines) * 100
        Write-Host "已完成 $percent% ..." 
    }
}

$sw.Close()
Write-Host "✅ 压力测试文件 $path 生成完毕 (约 1.8GB - 2.2GB)" -ForegroundColor Green
```

---

### 如何进行真正的性能压测？

当你拥有了一个 **5GB 以上** 的文件后，你可以观察到 `safemask` 极其硬核的表现：

#### 1. 监控磁盘 I/O
运行测试：
```powershell
# 记得把控制台编码设为 UTF8 避免输出乱码干扰
chcp 65001
Measure-Command { ./target/release/safemask --mode file --path test_big_5gb.log > output_big.txt }
```

#### 2. 观察任务管理器
在程序运行的那几秒钟：
*   **CPU**：点击“逻辑处理器”视图，你应该看到**所有核心**全部瞬间顶满。这证明 `Rayon` 的工作窃取（Work-stealing）算法正在疯狂压榨多核性能。
*   **内存**：重点来了！观察 `safemask` 的内存占用。你会发现，虽然你处理的是 5GB 的文件，但 **`safemask` 的内存占用（Private Bytes）可能非常低**。
    *   **原因**：这就是 `Mmap` 的魔力。它没有把 5GB 全部读进内存，而是让操作系统按需映射磁盘分页。这证明了你的程序具备处理“超大数据量”（超过物理内存容量）的能力。

#### 3. 结果验证
处理完大文件后，随机抽查最后几行：
```powershell
Get-Content output_big.txt -Tail 20
```
