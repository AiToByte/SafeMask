为了真正压测 **`safemask`** 的 **Mmap（内存映射）** 和 **Rayon（多核并行）** 特性，我们需要把数据量提升到 **GB 级别（例如 5GB - 10GB）**。

在 Windows PowerShell 中，高效生成大文件有两种推荐方案：

---

### 方案一：倍增法（最快，利用现有文件）
如果你已经生成了那个 200MB 的 `test_perf.log`，我们可以利用文件流直接把它快速复制并合并，实现容量翻倍。

**在 PowerShell 中运行以下代码：**

```powershell
# 将 200MB 的文件自我复制合并，运行 5 次就是 32 倍 (约 6.4GB)
$source = "test_perf.log"
$target = "test_big_5gb.log"

Write-Host "🚀 正在通过倍增法生成大文件..." -ForegroundColor Cyan

# 先拷贝一份作为基础
Copy-Item $source $target

# 循环 5 次，每次文件大小翻倍：200MB -> 400 -> 800 -> 1.6G -> 3.2G -> 6.4G
for ($i = 1; $i -le 5; $i++) {
    Write-Host "正在进行第 $i 次翻倍..."
    # 使用 CMD 的二进制拷贝模式，这是 Windows 下合并文件最快的方式
    cmd /c "copy /b $target + $target $target_tmp"
    Move-Item $target_tmp $target -Force
}

Write-Host "✅ 成功生成超大测试文件: $target" -ForegroundColor Green
```

---

### 方案二：高性能 .NET 流生成器（生成 1000 万行 ≈ 2GB）
如果你想生成更具随机性的数据，我们可以把循环次数加大。为了避免 PowerShell 自身的性能瓶颈，我们增大缓冲区。

```powershell
$path = "test_stress.log"
$lines = 10000000  # 1000 万行，约 1.8GB 到 2.2GB

Write-Host "🚀 正在生成 1000 万行压力测试数据..." -ForegroundColor Cyan

$sw = [System.IO.StreamWriter]::new((Join-Path (Get-Location) $path), $false, [System.Text.Encoding]::UTF8, 65536)

for ($i = 1; $i -le $lines; $i++) {
    # 减少随机数调用次数可以提速
    $sw.WriteLine("INFO [2026-01-09] User_$i IP: 192.168.1.1 Project: TopSecretProject Key: sk-ant-api03-L7zXXXXXXXXXXXXX123456789012345678901234")
    
    if ($i % 1000000 -eq 0) { Write-Host "已完成 $($i/1000000)0% ..." }
}

$sw.Close()
Write-Host "✅ 压力测试文件 $path 生成完毕" -ForegroundColor Green
```

---

### 如何进行真正的性能压测？

当你拥有了一个 **5GB 以上** 的文件后，你可以观察到 `safemask` 极其硬核的表现：

#### 1. 监控磁盘 I/O
运行测试：
```powershell
# 记得把控制台编码设为 UTF8 避免输出乱码干扰
chcp 65001
Measure-Command { ./target/release/safemask --mode file --path test_big_5gb.log > output_big.txt }
```

#### 2. 观察任务管理器
在程序运行的那几秒钟：
*   **CPU**：点击“逻辑处理器”视图，你应该看到**所有核心**全部瞬间顶满。这证明 `Rayon` 的工作窃取（Work-stealing）算法正在疯狂压榨多核性能。
*   **内存**：重点来了！观察 `safemask` 的内存占用。你会发现，虽然你处理的是 5GB 的文件，但 **`safemask` 的内存占用（Private Bytes）可能非常低**。
    *   **原因**：这就是 `Mmap` 的魔力。它没有把 5GB 全部读进内存，而是让操作系统按需映射磁盘分页。这证明了你的程序具备处理“超大数据量”（超过物理内存容量）的能力。

#### 3. 结果验证
处理完大文件后，随机抽查最后几行：
```powershell
Get-Content output_big.txt -Tail 20
```
